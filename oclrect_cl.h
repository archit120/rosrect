static const char *source =
"// Copyright Naoki Shibata 2018. Distributed under the MIT License.\n"
"\n"
"typedef char int8_t;\n"
"typedef short int16_t;\n"
"typedef int int32_t;\n"
"typedef long int64_t;\n"
"typedef unsigned char uint8_t;\n"
"typedef unsigned short uint16_t;\n"
"typedef unsigned int uint32_t;\n"
"typedef unsigned long uint64_t;\n"
"\n"
"__constant int rx[] = { 1,  1,  0, -1, -1, -1, 0, 1 };\n"
"__constant int ry[] = { 0, -1, -1, -1,  0,  1, 1, 1 };\n"
"\n"
"// --------------------------------\n"
"\n"
"int squ(int x) { return x * x; }\n"
"\n"
"int mirror(int x, int y, int iw, int ih) {\n"
"  int2 xy = (int2)(x, y);\n"
"  xy = clamp(xy, -xy, (int2)(iw, ih) * 2 - 2 - xy);\n"
"  return xy.x + xy.y * iw;\n"
"}\n"
"\n"
"uint32_t packlab(float3 clab) {\n"
"  uint32_t ret = 0;\n"
"  ret = clamp(convert_uint_rtn(clab.z * 1024), 0U, 1023U);\n"
"  ret = (ret << 10) | clamp(convert_uint_rtn(clab.y * 1024), 0U, 1023U);\n"
"  ret = (ret << 12) | clamp(convert_uint_rtn(clab.x * 4096), 0U, 4095U);\n"
"  return ret;\n"
"}\n"
"\n"
"float3 unpacklab(uint32_t plab) {\n"
"  float3 f = convert_float3((int3) (plab, plab >> 12, plab >> 22) & (int3) (4095, 1023, 1023));\n"
"  return f * (float3) (1.0f/4096, 1.0f/1024, 1.0f/1024) + (float3)(0.5f/4096, 0.5f/1024, 0.5f/1024);\n"
"}\n"
"\n"
"uint32_t packlabbl(int3 clab) {\n"
"  uint32_t ret = 0;\n"
"  ret = (uint32_t)clamp(clab.z, 0, 1023);\n"
"  ret = (ret << 10) | (uint32_t)clamp(clab.y, 0, 1023);\n"
"  ret = (ret << 12) | (uint32_t)clamp(clab.x, 0, 4095);\n"
"  return ret;\n"
"}\n"
"\n"
"int3 unpacklabbl(uint32_t plab) {\n"
"  return (int3) (plab, plab >> 12, plab >> 22) & (int3) (4095, 1023, 1023);\n"
"}\n"
"\n"
"float bicubicSub(float p0, float p1, float p2, float p3, float x) {\n"
"  float u, v, w;\n"
"  v = p1 - p2;\n"
"  w = p3 - p0;\n"
"  u = v * 3.0f + w;\n"
"  u = u * x   + (-4.0f * v + (p0 - p1 - w));\n"
"  u = u * x   + (p2 - p0);\n"
"  u = u * x * 0.5f + p1;\n"
"  return u;\n"
"}\n"
"\n"
"float bicubic(global float *p, float x, float y, int iw, int ih) {\n"
"  const int ix = (int)x, iy = (int)y;\n"
"\n"
"  return bicubicSub(bicubicSub(p[mirror(ix-1, iy-1,iw,ih)], p[mirror(ix  , iy-1,iw,ih)], p[mirror(ix+1, iy-1,iw,ih)], p[mirror(ix+2, iy-1,iw,ih)], x-ix),\n"
"		    bicubicSub(p[mirror(ix-1, iy  ,iw,ih)], p[mirror(ix  , iy  ,iw,ih)], p[mirror(ix+1, iy  ,iw,ih)], p[mirror(ix+2, iy  ,iw,ih)], x-ix),\n"
"		    bicubicSub(p[mirror(ix-1, iy+1,iw,ih)], p[mirror(ix  , iy+1,iw,ih)], p[mirror(ix+1, iy+1,iw,ih)], p[mirror(ix+2, iy+1,iw,ih)], x-ix),\n"
"		    bicubicSub(p[mirror(ix-1, iy+2,iw,ih)], p[mirror(ix  , iy+2,iw,ih)], p[mirror(ix+1, iy+2,iw,ih)], p[mirror(ix+2, iy+2,iw,ih)], x-ix), y-iy);\n"
"}\n"
"\n"
"// --------------------------------\n"
"\n"
"#define BLBLURSIZE 4\n"
"\n"
"__kernel void simpleJunction(global int *out, global int *in, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  const int p0 = y * iw + x;\n"
"  if (x >= 0 && y >= 0 && x <= (iw-1) && y <= (ih-1)) out[p0] = 0;\n"
"  if (x <= 0 || y <= 0 || x >= (iw-1) || y >= (ih-1)) return;\n"
"\n"
"  int c = in[p0] > 0;\n"
"\n"
"  if (c == 0) {\n"
"    out[p0] = 0;\n"
"    return;\n"
"  }\n"
"\n"
"  int count = 1;\n"
"\n"
"  for(int i=0;i<8;i++) {\n"
"    int p1 = p0 + rx[i] + ry[i] * iw;\n"
"    if (in[p1] > 0) count++;\n"
"  }\n"
"\n"
"  out[p0] = count == 1 ? 0 : count;\n"
"}\n"
"\n"
"__kernel void simpleConnect(global int *out, global int *in, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  const int p0 = y * iw + x;\n"
"  if (x >= 0 && y >= 0 && x <= (iw-1) && y <= (ih-1)) out[p0] = 0;\n"
"  if (x <= 1 || y <= 1 || x >= (iw-2) || y >= (ih-2)) return;\n"
"\n"
"  out[p0] = in[p0] != 0 ? 1 : 0;\n"
"\n"
"  if (in[p0] != 0) return;\n"
"\n"
"  //\n"
"\n"
"  if (in[p0-   1] == 2 && in[p0+   1] != 0) out[p0] = 1;\n"
"  if (in[p0-   1] != 0 && in[p0+   1] == 2) out[p0] = 1;\n"
"  if (in[p0-iw  ] == 2 && in[p0+iw  ] != 0) out[p0] = 1;\n"
"  if (in[p0-iw  ] != 0 && in[p0+iw  ] == 2) out[p0] = 1;\n"
"\n"
"  if (in[p0-iw-1] == 2 && in[p0+iw+1] == 2) out[p0] = 1;\n"
"  if (in[p0-iw+1] == 2 && in[p0+iw-1] == 2) out[p0] = 1;\n"
"\n"
"  if (in[p0   +1] == 2 && in[p0+iw-1] == 2) out[p0] = 1;\n"
"  if (in[p0   -1] == 2 && in[p0+iw+1] == 2) out[p0] = 1;\n"
"  if (in[p0-iw+1] == 2 && in[p0+iw  ] == 2) out[p0] = 1;\n"
"  if (in[p0-iw-1] == 2 && in[p0+iw  ] == 2) out[p0] = 1;\n"
"}\n"
"\n"
"__kernel void stringify(global int *out, global int *in, int mod2, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  const int p0 = y * iw + x;\n"
"  if (x >= 0 && y >= 0 && x <= (iw-1) && y <= (ih-1)) out[p0] = in[p0];\n"
"  if (x <= 0 || y <= 0 || x >= (iw-1) || y >= (ih-1)) return;\n"
"\n"
"  if (((x + y) & 1) != mod2) return;\n"
"\n"
"  if (in[p0-iw] != 0 && in[p0-1] != 0) out[p0] = 0;\n"
"  if (in[p0-iw] != 0 && in[p0+1] != 0) out[p0] = 0;\n"
"  if (in[p0+iw] != 0 && in[p0-1] != 0) out[p0] = 0;\n"
"  if (in[p0+iw] != 0 && in[p0+1] != 0) out[p0] = 0;\n"
"}\n"
"\n"
"__kernel void calcStrength(global int *out, global float *edge, global int *label, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  if (x <= 0 || y <= 0 || x >= (iw-1) || y >= (ih-1)) return;\n"
"  const int p0 = y * iw + x;\n"
"\n"
"  if (label[p0] <= 0) return;\n"
"\n"
"  atomic_add(&out[label[p0]], (int)(edge[p0] * edge[p0] * 10000.0f));\n"
"}\n"
"\n"
"__kernel void filterStrength(global int *labelinout, global int *str, int thre, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  if (x <= 0 || y <= 0 || x >= (iw-1) || y >= (ih-1)) return;\n"
"  const int p0 = y * iw + x;\n"
"\n"
"  if (labelinout[p0] <= 0 || str[labelinout[p0]] < thre) labelinout[p0] = -1;\n"
"}\n"
"\n"
"__kernel void blblur0(global uint32_t *out, global int8_t *edge, global uint32_t *in, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  if (x >= iw || y >= ih) return;\n"
"\n"
"  int wsum = 0, oe = edge[y*iw+x] != 0;\n"
"  int3 csum = 0;\n"
"\n"
"  for(int xx=0;xx>=-BLBLURSIZE;xx--) {\n"
"    if (x + xx < 0) break;\n"
"    if (x + xx > 0 && edge[y*iw+x+xx] != 0 && edge[y*iw+x+xx-1] == 0) break;\n"
"    if (x + xx > 0 && y < ih-1 && edge[y*iw+x+xx] == 0 && edge[y*iw+x+xx-1] != 0 && edge[(y+1)*iw+x+xx] != 0) break;\n"
"    wsum++;\n"
"    csum += unpacklabbl(in[y*iw+x+xx]);\n"
"  }\n"
"\n"
"  for(int xx=0;xx<=BLBLURSIZE;xx++) {\n"
"    if (x + xx > iw-1) break;\n"
"    if (x + xx < iw-1 && edge[y*iw+x+xx] == 0 && edge[y*iw+x+xx+1] != 0) break;\n"
"    if (oe && edge[y*iw+x+xx] == 0) break;\n"
"    wsum++;\n"
"    csum += unpacklabbl(in[y*iw+x+xx]);\n"
"  }\n"
"\n"
"  out[y*iw+x] = wsum == 0 ? in[y*iw+x] : packlabbl(csum / wsum);\n"
"}\n"
"\n"
"__kernel void blblur1(global uint32_t *out, global int8_t *edge, global uint32_t *in, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  if (x >= iw || y >= ih) return;\n"
"\n"
"  int wsum = 0, oe = edge[y*iw+x] != 0;\n"
"  int3 csum = 0;\n"
"\n"
"  for(int yy=0;yy>=-BLBLURSIZE;yy--) {\n"
"    if (y + yy < 0) break;\n"
"    if (y + yy > 0 && edge[(y+yy)*iw+x] != 0 && edge[(y+yy-1)*iw+x] == 0) break;\n"
"    if (y + yy > 0 && x < iw-1 && edge[(y+yy)*iw+x] == 0 && edge[(y+yy-1)*iw+x] != 0 && edge[(y+yy)*iw+x+1] != 0) break;\n"
"    wsum++;\n"
"    csum += unpacklabbl(in[(y+yy)*iw+x]);\n"
"  }\n"
"\n"
"  for(int yy=0;yy<=BLBLURSIZE;yy++) {\n"
"    if (y + yy > ih-1) break;\n"
"    if (y + yy < ih-1 && edge[(y+yy)*iw+x] == 0 && edge[(y+yy+1)*iw+x] != 0) break;\n"
"    if (oe && edge[(y+yy)*iw+x] == 0) break;\n"
"    wsum++;\n"
"    csum += unpacklabbl(in[(y+yy)*iw+x]);\n"
"  }\n"
"\n"
"  out[y*iw+x] = wsum == 0 ? in[y*iw+x] : packlabbl(csum / wsum);\n"
"}\n"
"\n"
"__kernel void quantize(global uint32_t *out, global uint32_t *in, int n0, int n1, int n2, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  if (x >= iw || y >= ih) return;\n"
"\n"
"  float3 v = unpacklab(in[y * iw + x]);\n"
"\n"
"  out[y * iw + x] = packlab((float3) (round(v.x * n0) / (float)n0,\n"
"				      round(v.y * n1) / (float)n1,\n"
"				      round(v.z * n2) / (float)n2));\n"
"}\n"
"\n"
"__kernel void despeckle(global uint32_t *out, global uint32_t *in, global float *edge, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  if (x >= iw || y >= ih) return;\n"
"\n"
"  const int p0 = y * iw + x;\n"
"\n"
"  out[p0] = in[p0];\n"
"  if (edge[p0] < 1e-6f) return;\n"
"\n"
"  float dist = 1e+10f;\n"
"  float3 labp0 = unpacklab(in[p0]);\n"
"  \n"
"  for(int yy=-1;yy<=1;yy++) {\n"
"    for(int xx=-1;xx<=1;xx++) {\n"
"      if (0 <=  x + xx &&  x + xx < iw && 0 <=  y + yy &&  y + yy < ih) {\n"
"	const int p1 = (y + yy) * iw + x + xx;\n"
"	if (edge[p1] >= 1e-6f) continue;\n"
"\n"
"	float d = distance(unpacklab(in[p1]), labp0);\n"
"	if (d < dist) {\n"
"	  out[p0] = in[p1];\n"
"	  dist = d;\n"
"	}\n"
"      }\n"
"    }\n"
"  }\n"
"}\n"
"\n"
"__kernel void mkMergeMask0(global int *out, global int *junctionIn, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  if (x >= iw || y >= ih) return;\n"
"  const int p0 = y * iw + x;\n"
"\n"
"  if (junctionIn[p0] != 0) {\n"
"    for(int yy=y-6;yy<=y+6;yy++) {\n"
"      for(int xx=x-6;xx<=x+6;xx++) {\n"
"	if (xx < 0 || iw <= xx || yy < 0 || ih <= yy) continue;\n"
"	int dsqu = squ(yy-y) + squ(xx-x);\n"
"	int p1 = yy * iw + xx;\n"
"	if (16 <= dsqu && dsqu < 36) out[p1] = 1;\n"
"      }\n"
"    }\n"
"  }\n"
"}\n"
"\n"
"__kernel void mkMergeMask1(global int *inout, global int *junctionIn, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  if (x >= iw || y >= ih) return;\n"
"  const int p0 = y * iw + x;\n"
"\n"
"  if (junctionIn[p0] == 2) {\n"
"    for(int yy=y-8;yy<=y+8;yy++) {\n"
"      for(int xx=x-8;xx<=x+8;xx++) {\n"
"	if (xx < 0 || iw <= xx || yy < 0 || ih <= yy) continue;\n"
"	int dsqu = squ(yy-y) + squ(xx-x);\n"
"	int p1 = yy * iw + xx;\n"
"	if (dsqu < 64) inout[p1] = 0;\n"
"      }\n"
"    }\n"
"  } else if (junctionIn[p0] != 0) {\n"
"    for(int yy=y-4;yy<=y+4;yy++) {\n"
"      for(int xx=x-4;xx<=x+4;xx++) {\n"
"	if (xx < 0 || iw <= xx || yy < 0 || ih <= yy) continue;\n"
"	int dsqu = squ(yy-y) + squ(xx-x);\n"
"	int p1 = yy * iw + xx;\n"
"	if (dsqu < 16) inout[p1] = 0;\n"
"      }\n"
"    }\n"
"  }\n"
"}\n"
"\n"
"__kernel void labelxPreprocess(global int *label, global int *pixin, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  if (x >= iw || y >= ih) return;\n"
"  const int p0 = y * iw + x;\n"
"\n"
"  //if (pixin[p0] <= 0) { label[p0] = -1; return; }\n"
"  if (y > 0 && pixin[p0] == pixin[p0-iw]) { label[p0] = p0-iw; return; }\n"
"  if (x > 0 && pixin[p0] == pixin[p0- 1]) { label[p0] = p0- 1; return; }\n"
"  label[p0] = p0;\n"
"}\n"
"\n"
"__kernel void labelMergeMain(global int *label, global int *pixin, global int *maskin, global int *edgein, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  if (x <= 0 || y <= 0 || x >= (iw-1) || y >= (ih-1)) return;\n"
"  const int p0 = y * iw + x;\n"
"\n"
"  int g = label[p0], og = g, p1, s;\n"
"  if (g == -1) return;\n"
"\n"
"  if (y > 0) {\n"
"    p1 = p0 - iw; s = label[p1];\n"
"    if (s < g && (pixin[p0] == pixin[p1] || maskin[p0] != 0) && edgein[p0] <= 0) g = s;\n"
"  }\n"
"\n"
"  if (x > 0) {\n"
"    p1 = p0 - 1; s = label[p1];\n"
"    if (s < g && (pixin[p0] == pixin[p1] || maskin[p0] != 0) && edgein[p0] <= 0) g = s;\n"
"  }\n"
"\n"
"  if (x < iw-1) {\n"
"    p1 = p0 + 1; s = label[p1];\n"
"    if (s < g && (pixin[p0] == pixin[p1] || maskin[p0] != 0) && edgein[p1] <= 0) g = s;\n"
"  }\n"
"\n"
"  if (y < ih-1) {\n"
"    p1 = p0 + iw; s = label[p1];\n"
"    if (s < g && (pixin[p0] == pixin[p1] || maskin[p0] != 0) && edgein[p1] <= 0) g = s;\n"
"  }\n"
"\n"
"  for(int j=0;j<8;j++) g = label[g];\n"
"\n"
"  if (g != og) {\n"
"    atomic_min(&label[og], g);\n"
"    atomic_min(&label[p0], g);\n"
"  }\n"
"}\n"
"\n"
"__kernel void calcSize(global int *out,\n"
"		       global int *label, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  if (x >= iw || y >= ih) return;\n"
"  const int p0 = y * iw + x;\n"
"\n"
"  int l = label[p0];\n"
"  if (l != -1) {\n"
"    atomic_inc(&out[l]);\n"
"  }\n"
"}\n"
"\n"
"__kernel void despeckle2(global uint32_t *labelinout, global int *sizein, int thre, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  if (x >= iw || y >= ih) return;\n"
"\n"
"  const int p0 = y * iw + x;\n"
"\n"
"  if (sizein[labelinout[p0]] > thre) return;\n"
"\n"
"  int maxSize = 0, maxLabel = labelinout[p0];\n"
"  \n"
"  for(int yy=-1;yy<=1;yy++) {\n"
"    for(int xx=-1;xx<=1;xx++) {\n"
"      if (0 <= x + xx &&  x + xx < iw && 0 <= y + yy && y + yy < ih) {\n"
"	const int p1 = (y + yy) * iw + x + xx;\n"
"	if (sizein[labelinout[p1]] > maxSize) {\n"
"	  maxSize = sizein[labelinout[p1]];\n"
"	  maxLabel = labelinout[p1];\n"
"	}\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"  labelinout[p0] = maxLabel;\n"
"}\n"
"\n"
"__kernel void markBoundary(global int *out, global int *in, global int *edge, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  const int p0 = y * iw + x;\n"
"  if (x >= iw || y >= ih) return;\n"
"  if (x <= 1 || y <= 1 || x >= iw-2 || y >= ih-2) { out[p0] = -1; return; }\n"
"\n"
"  int nearEdge = 0;\n"
"  int c0 = in[p0];\n"
"\n"
"  for(int yy=-2;yy<=2;yy++) {\n"
"    for(int xx=-2;xx<=2;xx++) {\n"
"      int p1 = p0 + yy * iw + xx;\n"
"      if (in[p1] != c0) nearEdge = 1;\n"
"    }\n"
"  }\n"
"\n"
"  out[p0] = nearEdge ? in[p0] : -1;\n"
"}\n"
"\n"
"__kernel void colorReassign_pass0(global int *countOut, global int *lout, global int *aout, global int *bout, global uint32_t *labIn, global int *labelin, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  if (x >= iw || y >= ih) return;\n"
"\n"
"  int p0 = y * iw + x;\n"
"\n"
"  int lb = labelin[p0];\n"
"  if (lb == -1) return;\n"
"\n"
"  float3 v = unpacklab(labIn[p0]);\n"
"\n"
"  atomic_add(&lout[lb], (int)(v.x * 128));\n"
"  atomic_add(&aout[lb], (int)(v.y * 128));\n"
"  atomic_add(&bout[lb], (int)(v.z * 128));\n"
"  atomic_inc(&countOut[lb]);\n"
"}\n"
"\n"
"__kernel void colorReassign_pass1(global uint32_t *labOut, global int *countIn, global int *lin, global int *ain, global int *bin, global int *labelin, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  if (x >= iw || y >= ih) return;\n"
"\n"
"  int p0 = y * iw + x;\n"
"\n"
"  int lb = labelin[p0];\n"
"  if (lb == -1) return;\n"
"\n"
"  float3 v;\n"
"  v.x = (float)lin[lb] / (countIn[lb] * 128);\n"
"  v.y = (float)ain[lb] / (countIn[lb] * 128);\n"
"  v.z = (float)bin[lb] / (countIn[lb] * 128);\n"
"  \n"
"  labOut[p0] = packlab(v);\n"
"}\n"
"\n"
"// nentry = iw * ih * 2 / 5\n"
"__kernel void reduceLS(global int *out, global int *boundaryin, global int *lsidin, int iw, int ih, int nentry) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  if (x <= 0 || y <= 0 || x >= (iw-1) || y >= (ih-1)) return;\n"
"  const int p0 = y * iw + x, lsid = lsidin[p0];\n"
"\n"
"  if (lsid <= 0) return;\n"
"\n"
"  int bid = 0, hash = 0;\n"
"\n"
"  for(int yy=-3;yy<=3;yy++) {\n"
"    if (y+yy < 0 || ih <= y+yy) continue;\n"
"    for(int xx=-3;xx<=3;xx++) {\n"
"      if (x+xx < 0 || iw <= x+xx) continue;\n"
"\n"
"      const int p1 = (y + yy) * iw + x + xx;\n"
"      if (boundaryin[p1] <= 0) continue;\n"
"\n"
"      if (bid != boundaryin[p1]) {\n"
"	bid = boundaryin[p1];\n"
"	hash = (((unsigned int)lsid * (unsigned int)bid) & 0x7fffffff) % (unsigned int)nentry;\n"
"      }\n"
"\n"
"      int oldid = out[hash*5+0];\n"
"\n"
"      if (oldid == 0) {\n"
"	oldid = atomic_cmpxchg(&out[hash*5+0], 0, lsid);\n"
"	if (oldid != 0 && oldid != lsid) continue;\n"
"      }\n"
"\n"
"      if (oldid != lsid) continue;\n"
"\n"
"      atomic_max(&out[hash*5+1], iw-x);\n"
"      atomic_max(&out[hash*5+2],    x);\n"
"      atomic_max(&out[hash*5+3], ih-y);\n"
"      atomic_max(&out[hash*5+4],    y);\n"
"    }\n"
"  }\n"
"}\n"
;
