static const char *source =
"// Copyright Naoki Shibata 2018. Distributed under the MIT License.\n"
"\n"
"#ifdef ENABLE_ATOMICS64\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"#endif\n"
"\n"
"typedef char int8_t;\n"
"typedef short int16_t;\n"
"typedef int int32_t;\n"
"typedef long int64_t;\n"
"typedef unsigned char uint8_t;\n"
"typedef unsigned short uint16_t;\n"
"typedef unsigned int uint32_t;\n"
"typedef unsigned long uint64_t;\n"
"\n"
"#ifndef NULL\n"
"#define NULL ((global void *)0)\n"
"#endif\n"
"\n"
"#define MINEDGELEN 1 // 2\n"
"#define MINNINDEX 4\n"
"\n"
"#ifndef NDEBUG\n"
"#define ASSERT(x, str) { if (!(x)) { printf((constant char *) \"Assertion failure : %s\\n\", str); } }\n"
"#else\n"
"#define ASSERT(x, str) {}\n"
"#endif\n"
"\n"
"typedef struct LS_t { // 56 bytes\n"
"  float2 startCoords, endCoords;\n"
"  int startIndex, endIndex;\n"
"  int leftPtr, rightPtr;\n"
"\n"
"  int startCount, endCount;\n"
"  int maxDist;\n"
"  int polyid;\n"
"  int npix;\n"
"  int level;\n"
"} LS_t;\n"
"\n"
"typedef struct LSX_t { // 56 bytes\n"
"  int64_t mx00, mx01, mx11, my0, my1;\n"
"  short2 dirSE, vDirSE;\n"
"  int distSquSE, padding;\n"
"} LSX_t;\n"
"\n"
"float distanceSqu(float vx, float vy, float wx, float wy) {\n"
"  return (vx - wx) * (vx - wx) + (vy - wy) * (vy - wy);\n"
"}\n"
"\n"
"float2 closestPoint(float vx, float vy, float wx, float wy, float px, float py) {\n"
"  float l2 = distanceSqu(vx, vy, wx, wy);\n"
"  if (l2 <= 1e-4f) return (float2)(vx, vy);\n"
"  float t = ((px - vx) * (wx - vx) + (py - vy) * (wy - vy)) / l2;\n"
"  if (t < 0.0f) return (float2)(vx, vy);\n"
"  if (t > 1.0f) return (float2)(wx, wy);\n"
"\n"
"  return (float2) (vx + t * (wx - vx), vy + t * (wy - vy));\n"
"}\n"
"\n"
"//\n"
"\n"
"__constant int rx[] = { 1,  1,  0, -1, -1, -1, 0, 1 };\n"
"__constant int ry[] = { 0, -1, -1, -1,  0,  1, 1, 1 };\n"
"\n"
"__kernel void simpleJunction(global int *out, global int *in, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  const int p0 = y * iw + x;\n"
"  if (x >= 0 && y >= 0 && x <= (iw-1) && y <= (ih-1)) out[p0] = 0;\n"
"  if (x <= 0 || y <= 0 || x >= (iw-1) || y >= (ih-1)) return;\n"
"\n"
"  int c = in[p0] != 0;\n"
"\n"
"  if (c == 0) {\n"
"    out[p0] = 0;\n"
"    return;\n"
"  }\n"
"\n"
"  int count = 1;\n"
"\n"
"  for(int i=0;i<8;i++) {\n"
"    int p1 = p0 + rx[i] + ry[i] * iw;\n"
"    if (in[p1] != 0) count++;\n"
"  }\n"
"\n"
"  out[p0] = count == 1 ? 0 : count;\n"
"}\n"
"\n"
"__kernel void simpleConnect(global int *out, global int *in, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  if (x <= 1 || y <= 1 || x >= (iw-2) || y >= (ih-2)) return;\n"
"  const int p0 = y * iw + x;\n"
"\n"
"  out[p0] = in[p0] != 0 ? 1 : 0;\n"
"\n"
"  if (in[p0] != 0) return;\n"
"\n"
"  //\n"
"\n"
"  if (in[p0-     2] != 0 && in[p0-   1] == 2 && in[p0+   1] == 2 && in[p0+     2] != 0) out[p0] = 1;\n"
"  if (in[p0-iw*2  ] != 0 && in[p0-iw  ] == 2 && in[p0+iw  ] == 2 && in[p0+iw*2  ] != 0) out[p0] = 1;\n"
"\n"
"  if (in[p0-iw*2-2] != 0 && in[p0-iw-1] == 2 && in[p0+iw+1] == 2 && in[p0+iw*2+2] != 0) out[p0] = 1;\n"
"  if (in[p0-iw*2+2] != 0 && in[p0-iw+1] == 2 && in[p0+iw-1] == 2 && in[p0+iw*2-2] != 0) out[p0] = 1;\n"
"\n"
"  if (in[p0     +2] != 0 && in[p0   +1] == 2 && in[p0+iw-1] == 2 && in[p0+iw  -2] != 0) out[p0] = 1;\n"
"  if (in[p0     -2] != 0 && in[p0   -1] == 2 && in[p0+iw+1] == 2 && in[p0+iw  +2] != 0) out[p0] = 1;\n"
"  if (in[p0-iw*2+1] != 0 && in[p0-iw+1] == 2 && in[p0+iw  ] == 2 && in[p0+iw*2  ] != 0) out[p0] = 1;\n"
"  if (in[p0-iw*2-1] != 0 && in[p0-iw-1] == 2 && in[p0+iw  ] == 2 && in[p0+iw*2  ] != 0) out[p0] = 1;\n"
"}\n"
"\n"
"__kernel void stringify(global int *out, global int *in, int mod2, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  const int p0 = y * iw + x;\n"
"  if (x >= 0 && y >= 0 && x <= (iw-1) && y <= (ih-1)) out[p0] = in[p0];\n"
"  if (x <= 0 || y <= 0 || x >= (iw-1) || y >= (ih-1)) return;\n"
"\n"
"  if (((x + y) & 1) != mod2) return;\n"
"\n"
"  if (in[p0-iw] != 0 && in[p0-1] != 0) out[p0] = 0;\n"
"  if (in[p0-iw] != 0 && in[p0+1] != 0) out[p0] = 0;\n"
"  if (in[p0+iw] != 0 && in[p0-1] != 0) out[p0] = 0;\n"
"  if (in[p0+iw] != 0 && in[p0+1] != 0) out[p0] = 0;\n"
"}\n"
"\n"
"__kernel void removeBranch(global int *out, global int *in, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  const int p0 = y * iw + x;\n"
"  if (x >= 0 && y >= 0 && x <= (iw-1) && y <= (ih-1)) out[p0] = 0;\n"
"  if (x <= 0 || y <= 0 || x >= (iw-1) || y >= (ih-1)) return;\n"
"\n"
"  int c = in[p0];\n"
"\n"
"  if (c == 0) {\n"
"    out[p0] = 0;\n"
"    return;\n"
"  }\n"
"\n"
"  int count = 0;\n"
"\n"
"  for(int i=0;i<8;i++) {\n"
"    int p1 = p0 + rx[i] + ry[i] * iw;\n"
"    if (in[p1] != 0) count++;\n"
"  }\n"
"\n"
"  out[p0] = count <= 2 ? 1 : 0;\n"
"}\n"
"\n"
"__kernel void countEnds(global int *out, global int *junction, global int *label, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  if (x <= 0 || y <= 0 || x >= (iw-1) || y >= (ih-1)) return;\n"
"  const int p0 = y * iw + x;\n"
"\n"
"  if (junction[p0] == 2) out[label[p0]]++;\n"
"}\n"
"\n"
"__kernel void breakLoops(global int *edgeinout, global int *labelinout, global int *nEnds, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  if (x <= 0 || y <= 0 || x >= (iw-1) || y >= (ih-1)) return;\n"
"  const int p0 = y * iw + x;\n"
"\n"
"  if (labelinout[p0] != p0) return;\n"
"  if (nEnds[p0] == 0) {\n"
"    edgeinout[p0] = 0;\n"
"    labelinout[p0] = -1;\n"
"  }\n"
"}\n"
"\n"
"int2 getnp(global int *labelin, int p0, int iw) {\n"
"  int l = labelin[p0];\n"
"\n"
"  int2 ret;\n"
"\n"
"  int i;\n"
"\n"
"  for(i=0;i<8;i++) {\n"
"    int p1 = p0 + rx[i] + ry[i] * iw;\n"
"    if (labelin[p1] == l) break;\n"
"  }\n"
"\n"
"  ret.x = i < 8 ? (p0 + rx[i] + ry[i] * iw) : p0;\n"
"\n"
"  for(i++;i<8;i++) {\n"
"    int p1 = p0 + rx[i] + ry[i] * iw;\n"
"    if (labelin[p1] == l) break;\n"
"  }\n"
"\n"
"  ret.y = i < 8 ? (p0 + rx[i] + ry[i] * iw) : p0;\n"
"\n"
"  return ret;\n"
"}\n"
"\n"
"__kernel void findEnds0(global int *nextout, global int *prevout, global int *flagout, global int *labelin, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  const int p0 = y * iw + x;\n"
"\n"
"  if (x >= 0 && y >= 0 && x <= (iw-1) && y <= (ih-1)) {\n"
"    nextout[p0] = prevout[p0] = flagout[p0] = -1;\n"
"  }\n"
"  if (x <= 0 || y <= 0 || x >= (iw-1) || y >= (ih-1) || labelin[p0] == -1) return;\n"
"\n"
"  int2 np = getnp(labelin, p0, iw);\n"
"\n"
"  nextout[p0] = np.x;\n"
"  prevout[p0] = np.y;\n"
"\n"
"  int flag = 0;\n"
"\n"
"  if (np.x != p0) {\n"
"    int2 nnp = getnp(labelin, np.x, iw);\n"
"    if (nnp.x == p0) flag |= 1;\n"
"  }\n"
"\n"
"  if (np.y != p0) {\n"
"    int2 pnp = getnp(labelin, np.y, iw);\n"
"    if (pnp.y == p0) flag |= 2;\n"
"  }\n"
"\n"
"  flagout[p0] = flag;\n"
"}\n"
"\n"
"__kernel void findEnds1(global int *nextout, global int *prevout, global int *flaginout, global int *nextin, global int *previn, global int *labelin, int page, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  const int p0 = y * iw + x;\n"
"\n"
"  if (x >= 0 && y >= 0 && x <= (iw-1) && y <= (ih-1)) {\n"
"    nextout[p0] = prevout[p0] = -1;\n"
"  }\n"
"  if (x <= 0 || y <= 0 || x >= (iw-1) || y >= (ih-1) || labelin[p0] == -1) return;\n"
"\n"
"  bool revn = page == 0 ? ((flaginout[p0] & 1) != 0) : ((flaginout[p0] & 4) != 0);\n"
"  bool revp = page == 0 ? ((flaginout[p0] & 2) != 0) : ((flaginout[p0] & 8) != 0);\n"
"  int nn = nextin[p0], pp = previn[p0];\n"
"\n"
"  for(int i=0;i<8;i++) {\n"
"    int nn2 = revn ? previn[nn] : nextin[nn];\n"
"    int pp2 = revp ? nextin[pp] : previn[pp];\n"
"\n"
"    int nflag = flaginout[nn];\n"
"    int pflag = flaginout[pp];\n"
"\n"
"    if (page != 0) { nflag >>= 2; pflag >>= 2; }\n"
"\n"
"    revn = revn ? ((nflag & 2) == 0) : ((nflag & 1) != 0);\n"
"    revp = revp ? ((pflag & 1) == 0) : ((pflag & 2) != 0);\n"
"\n"
"    nn = nn2;\n"
"    pp = pp2;\n"
"  }\n"
"\n"
"  nextout[p0] = nn;\n"
"  prevout[p0] = pp;\n"
"\n"
"  int f = flaginout[p0];\n"
"\n"
"  if (page == 0) {\n"
"    f &= 3;\n"
"    f |= revn ? 4 : 0;\n"
"    f |= revp ? 8 : 0;\n"
"  } else {\n"
"    f &= (3 << 2);\n"
"    f |= revn ? 1 : 0;\n"
"    f |= revp ? 2 : 0;\n"
"  }\n"
"\n"
"  flaginout[p0] = f;\n"
"}\n"
"\n"
"__kernel void findEnds2(global int *numout, global int *linkout, global int *nextin, global int *previn, global int *labelin, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  const int p0 = y * iw + x;\n"
"  if (x >= 0 && y >= 0 && x <= (iw-1) && y <= (ih-1)) { numout[p0] = 0; linkout[p0] = -1; }\n"
"  if (x <= 0 || y <= 0 || x >= (iw-1) || y >= (ih-1)) return;\n"
"\n"
"  if (labelin[p0] == -1) {\n"
"    linkout[p0] = -1;\n"
"    numout[p0] = 0;\n"
"    return;\n"
"  }\n"
"\n"
"  int2 np = getnp(labelin, p0, iw);\n"
"\n"
"  linkout[p0] = nextin[p0] < previn[p0] ? np.x : np.y;\n"
"  numout[p0] = linkout[p0] == p0 ? 0 : 1;\n"
"}\n"
"\n"
"__kernel void number(global int *numout, global int *linkout, global int *numin, global int *linkin, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  const int p0 = y * iw + x;\n"
"  if (x >= 0 && y >= 0 && x <= (iw-1) && y <= (ih-1)) { numout[p0] = 0; linkout[p0] = -1; }\n"
"  if (x <= 0 || y <= 0 || x >= (iw-1) || y >= (ih-1)) return;\n"
"\n"
"  if (linkin[p0] == -1) {\n"
"    numout[p0] = numin[p0];\n"
"    linkout[p0] = linkin[p0];\n"
"    return;\n"
"  }\n"
"\n"
"  int no = numin[p0], lo = linkin[p0];\n"
"\n"
"  for(int i=0;i<32;i++) {\n"
"    if (!(0 < lo && lo < (iw*ih))) return;\n"
"\n"
"    no += numin[lo];\n"
"    lo = linkin[lo];\n"
"  }\n"
"\n"
"  numout[p0] = no;\n"
"  linkout[p0] = lo;\n"
"}\n"
"\n"
"__kernel void labelpl_preprocess(global int *label, global int *pixinout, global int *flags, int maxpass, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  if (x >= iw || y >= ih) return;\n"
"  const int p0 = y * iw + x;\n"
"\n"
"  label[p0] = pixinout[p0] == 0 ? 0 : p0;\n"
"  pixinout[p0] = pixinout[p0] == 0 ? 0 : pixinout[p0]+1;\n"
"\n"
"  if (y == 0 && x < maxpass+1) {\n"
"    flags[x] = x == 0 ? 1 : 0;\n"
"  }\n"
"}\n"
"\n"
"__kernel void labelpl_main(global int *label, global int *pix, global int *flags, int pass, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  if (x == 0 || y == 0 || x >= iw-1 || y >= ih-1) return;\n"
"  const int p0 = y * iw + x;\n"
"\n"
"  if (flags[pass-1] == 0 || pix[p0] == 0) return;\n"
"\n"
"  int g = label[p0], og = g, s;\n"
"\n"
"  for(int i=0;i<8;i++) {\n"
"    int p1 = p0 + rx[i] + ry[i] * iw;\n"
"    s = label[p1];\n"
"    if (s < g && abs_diff(pix[p0], pix[p1]) <= 1) g = s;\n"
"  }\n"
"\n"
"  for(int j=0;j<8;j++) {\n"
"    ASSERT(0 <= g && g < (iw*ih), \"labelpl_main g\");\n"
"\n"
"    int s0 = label[g];\n"
"    if (s0 >= g) break;\n"
"    g = s0;\n"
"  }\n"
"\n"
"  if (g != og) {\n"
"    ASSERT(0 <= og && og < (iw*ih), \"labelpl_main og\");\n"
"\n"
"    atomic_min(&label[og], g);\n"
"    atomic_min(&label[p0], g);\n"
"    flags[pass] = 1;\n"
"  }\n"
"}\n"
"\n"
"__kernel void calcSize(global int *out,\n"
"		       global int *label, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  if (x >= iw || y >= ih) return;\n"
"  const int p0 = y * iw + x;\n"
"\n"
"  int b = label[p0];\n"
"  if (b != 0) atomic_inc(&out[b]);\n"
"}\n"
"\n"
"__kernel void filterSize(global int *out,\n"
"			 global int *labelin,\n"
"			 global int *sizein,\n"
"			 int sizethre, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  if (x >= iw || y >= ih) return;\n"
"  const int p0 = y * iw + x;\n"
"\n"
"  int b = labelin[p0];\n"
"\n"
"  out[p0] = sizein[b] > sizethre ? b : 0;\n"
"}\n"
"\n"
"__kernel void relabel_pass0(global int *table, global int *labelin, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  if (x == 0 || y == 0 || x >= iw-1 || y >= ih-1) return;\n"
"  const int p0 = y * iw + x;\n"
"\n"
"  int g = labelin[p0];\n"
"\n"
"  if (g == 0 || p0 != g) {\n"
"    return;\n"
"  }\n"
"\n"
"  ASSERT(0 < g && (g+1) < (iw*ih), \"relabel_pass0 g\");\n"
"\n"
"  int rl = table[g+1];\n"
"  if (rl == 0) {\n"
"    int rl = atomic_inc(&table[0]) + 1;\n"
"    table[g+1] = rl;\n"
"  }\n"
"}\n"
"\n"
"__kernel void relabel_pass1(global int *labelinout, global int *tablein, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  const int p0 = y * iw + x;\n"
"\n"
"  if (x < 0 || y < 0 || x > iw-1 || y > ih-1) return;\n"
"\n"
"  if (x == 0 || y == 0 || x >= iw-1 || y >= ih-1) {\n"
"    labelinout[p0] = 0;\n"
"    return;\n"
"  }\n"
"\n"
"  int g = labelinout[p0];\n"
"\n"
"  if (g == 0) {\n"
"    return;\n"
"  }\n"
"\n"
"  ASSERT(0 < g && (g+1) < (iw*ih), \"relabel_pass1 g\");\n"
"\n"
"  labelinout[p0] = tablein[g+1];\n"
"}\n"
"\n"
"global LS_t *leftLS(global LS_t *g, global LS_t *lsList) {\n"
"  if (g->leftPtr == 0) return NULL;\n"
"  global LS_t *p = &lsList[g->leftPtr];\n"
"  if (p->polyid != g->polyid) return NULL;\n"
"  return p;\n"
"}\n"
"\n"
"global LS_t *rightLS(global LS_t *g, global LS_t *lsList) {\n"
"  if (g->leftPtr == 0) return NULL;\n"
"  global LS_t *p = &lsList[g->rightPtr];\n"
"  if (p->polyid != g->polyid) return NULL;\n"
"  return p;\n"
"}\n"
"\n"
"//\n"
"\n"
"// pass 0a : Construct the original lsList, find endIndex\n"
"__kernel void mkpl_pass0a(global void *lsList, int lsListSize, global int *numberin, global int *labelin, global int *flags, int maxIter, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"\n"
"  if (y == 0 && x < maxIter+1) {\n"
"    flags[x] = x == 0 ? 1 : 0;\n"
"  }\n"
"\n"
"  if (x == 0 || y == 0 || x >= iw-1 || y >= ih-1) return;\n"
"  const int p0 = y * iw + x;\n"
"\n"
"  int g = labelin[p0];\n"
"  int n = numberin[p0];\n"
"\n"
"  if (g == 0) return;\n"
"\n"
"  global LS_t *gp = lsList;\n"
"\n"
"  if (g < 0 || lsListSize <= (g+1)*sizeof(LS_t)) {\n"
"#ifndef NDEBUG\n"
"    printf((constant char *)\"Too many linesegemnts at mkpl_pass0a g=%d\\n\", g);\n"
"#endif\n"
"    return;\n"
"  }\n"
"  \n"
"  if (n == 1) {\n"
"    gp[g].startCoords = (float2) (x, y);\n"
"    gp[g].level = 0;\n"
"    atomic_inc(&gp[g].startCount);\n"
"  }\n"
"\n"
"  atomic_inc(&gp[g].npix);\n"
"  atomic_max(&gp[g].endIndex, n);\n"
"  atomic_max((global int *)lsList, g);\n"
"}\n"
"\n"
"// pass 0b : Construct the original lsList(continued)\n"
"__kernel void mkpl_pass0b(global void *lsList, int lsListSize, global int *numberin, global int *labelin, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  if (x == 0 || y == 0 || x >= iw-1 || y >= ih-1) return;\n"
"  const int p0 = y * iw + x;\n"
"\n"
"  int g = labelin[p0];\n"
"  int n = numberin[p0];\n"
"\n"
"  if (g == 0) return;\n"
"\n"
"  global LS_t *gp = lsList;\n"
"\n"
"  if (g < 0 || lsListSize <= (g+1)*sizeof(LS_t)) {\n"
"#ifndef NDEBUG\n"
"    printf((constant char *)\"Too many linesegemnts at mkpl_pass0b\\n\");\n"
"#endif\n"
"    return;\n"
"  }\n"
"\n"
"  int endIndex = gp[g].endIndex;\n"
"\n"
"  if (n == endIndex) {\n"
"    if (gp[g].startCount == 1 && gp[g].npix >= 2) { // ??\n"
"      if (atomic_inc(&gp[g].endCount) == 0) {\n"
"	gp[g].endCoords = (float2)(x, y);\n"
"	gp[g].polyid = labelin[p0];\n"
"      }\n"
"    } else {\n"
"      gp[g].polyid = 0;\n"
"    }\n"
"  }\n"
"}\n"
"\n"
"// pass 1 : Find the max distance\n"
"__kernel void mkpl_pass1(global void *lsList, int lsListSize, global int *tmp, global int *numberin, global int *labelin, global int *randin, global int *flags, int nIter, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  if (x >= iw || y >= ih) return;\n"
"  const int p0 = y * iw + x;\n"
"\n"
"  if (flags[nIter-1] == 0) return;\n"
"\n"
"  int g = labelin[p0];\n"
"\n"
"  if (g == 0) return;\n"
"\n"
"  global LS_t *gp = lsList;\n"
"\n"
"  if (g < 0 || lsListSize <= (g+1)*sizeof(LS_t)) {\n"
"#ifndef NDEBUG\n"
"    printf((constant char *)\"Too many linesegemnts at mkpl_pass1\\n\");\n"
"#endif\n"
"    return;\n"
"  }\n"
"\n"
"  if (gp[g].polyid == 0) return;\n"
"\n"
"  int x0 = gp[g].startCoords.x, y0 = gp[g].startCoords.y;\n"
"  int x1 = gp[g].endCoords.x, y1 = gp[g].endCoords.y;\n"
"\n"
"  float2 cp = closestPoint(x0, y0, x1, y1, x, y);\n"
"  int dist = (int)(hypot(cp.x - x, cp.y - y) * 65536);\n"
"  dist ^= (randin[p0] & 0x1fff);\n"
"\n"
"  tmp[p0] = dist;\n"
"  atomic_max(&gp[g].maxDist, dist);\n"
"}\n"
"\n"
"// pass 2 : Subdivide\n"
"__kernel void mkpl_pass2(global void *newlsList, global void *lsList, int lsListSize, global int *tmp, global int *numberin, global int *labelin, global int *randin, global int *flags, int nIter, float minerror, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  if (x >= iw || y >= ih) return;\n"
"  const int p0 = y * iw + x;\n"
"\n"
"  if (flags[nIter-1] == 0) return;\n"
"\n"
"  int g = labelin[p0];\n"
"  int n = numberin[p0];\n"
"\n"
"  if (g == 0) return;\n"
"\n"
"  global LS_t *gp = lsList;\n"
"\n"
"  if (g < 0 || lsListSize <= (g+1)*sizeof(LS_t)) {\n"
"#ifndef NDEBUG\n"
"    printf((constant char *)\"Too many linesegemnts at mkpl_pass2 (a)\\n\");\n"
"#endif\n"
"    return;\n"
"  }\n"
"\n"
"  if (gp[g].polyid == 0) return;\n"
"\n"
"  if (gp[g].endIndex - gp[g].startIndex < MINNINDEX-1) return;\n"
"  if (gp[g].startCount > 1 || gp[g].endCount > 1) return;\n"
"\n"
"  int maxDist = gp[g].maxDist;\n"
"\n"
"  if (tmp[p0] != maxDist) return;\n"
"  if (maxDist < ((int)(minerror * 65536))) return;\n"
"\n"
"  if (maxDist < (minerror * 3 * 65536) && (float)maxDist*maxDist / distanceSqu(gp[g].startCoords.x, gp[g].startCoords.y, gp[g].endCoords.x, gp[g].endCoords.y) < 100000.0f) return;\n"
"\n"
"  if (distanceSqu(x, y, gp[g].startCoords.x, gp[g].startCoords.y) < (MINEDGELEN * MINEDGELEN)) return;\n"
"  if (distanceSqu(x, y, gp[g].endCoords.x  , gp[g].endCoords.y  ) < (MINEDGELEN * MINEDGELEN)) return;\n"
"\n"
"  int gr = gp[g].rightPtr;\n"
"\n"
"  ASSERT(0 <= gr && gr < lsListSize-1, \"mkpl_pass2 gr\");\n"
"\n"
"  //\n"
"\n"
"  int gn = atomic_inc((global int *)newlsList) + 1;\n"
"\n"
"  global LS_t *ngp = newlsList;\n"
"\n"
"  if (gn < 0 || lsListSize <= (gn+1)*sizeof(LS_t)) {\n"
"#ifndef NDEBUG\n"
"    printf((constant char *)\"Too many linesegemnts at mkpl_pass2 (b)\\n\");\n"
"#endif\n"
"    return;\n"
"  }\n"
"\n"
"  ngp[gn].startIndex = n;\n"
"  ngp[gn].endIndex = gp[g].endIndex;\n"
"  ngp[gn].startCoords.x = x;\n"
"  ngp[gn].startCoords.y = y;\n"
"  ngp[gn].endCoords.x = gp[g].endCoords.x;\n"
"  ngp[gn].endCoords.y = gp[g].endCoords.y;\n"
"  ngp[gn].leftPtr = g;\n"
"  ngp[gn].rightPtr = gp[g].rightPtr;\n"
"  ngp[gn].maxDist = 0;\n"
"  ngp[gn].polyid = gp[g].polyid;\n"
"  ngp[gn].level = maxDist;\n"
"  \n"
"  ngp[g].endIndex = n;\n"
"  ngp[g].endCoords.x = x;\n"
"  ngp[g].endCoords.y = y;\n"
"  ngp[g].rightPtr = gn;\n"
"  ngp[g].maxDist = 0;\n"
"\n"
"  if (gr != 0) ngp[gr].leftPtr = gn;\n"
"}\n"
"\n"
"// pass 3 : Update labels\n"
"__kernel void mkpl_pass3(global void *lsList, int lsListSize, global int *numberin, global int *labelinout, global int *flags, int nIter, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  if (x >= iw || y >= ih) return;\n"
"  const int p0 = y * iw + x;\n"
"\n"
"  if (flags[nIter-1] == 0) return;\n"
"\n"
"  int g = labelinout[p0];\n"
"\n"
"  if (g == 0) return;\n"
"\n"
"  global LS_t *gp = lsList;\n"
"\n"
"  if (g < 0 || lsListSize <= (g+1)*sizeof(LS_t)) {\n"
"#ifndef NDEBUG\n"
"    printf((constant char *)\"Too many linesegemnts at mkpl_pass3\\n\");\n"
"#endif\n"
"    return;\n"
"  }\n"
"\n"
"  if (gp[g].polyid == 0) return;\n"
"\n"
"  int n = numberin[p0];\n"
"\n"
"  if (gp[g].endIndex < n) {\n"
"    labelinout[p0] = gp[g].rightPtr;\n"
"    flags[nIter] = 1;\n"
"  }\n"
"}\n"
"\n"
"__kernel void mkpl_pass4(global void *lsList, int lsListSize, global int *numberout, global int *labelin, float minerror, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  if (x >= iw || y >= ih) return;\n"
"  const int p0 = y * iw + x;\n"
"\n"
"  int g = labelin[p0];\n"
"\n"
"  if (g == 0) return;\n"
"\n"
"  global LS_t *gp = lsList;\n"
"\n"
"  if (g < 0 || lsListSize <= (g+1)*sizeof(LS_t)) {\n"
"#ifndef NDEBUG\n"
"    printf((constant char *)\"Too many linesegemnts at mkpl_pass3\\n\");\n"
"#endif\n"
"    return;\n"
"  }\n"
"\n"
"  if (gp[g].polyid == 0) return;\n"
"\n"
"  int x0 = gp[g].startCoords.x, y0 = gp[g].startCoords.y;\n"
"  int x1 = gp[g].endCoords.x, y1 = gp[g].endCoords.y;\n"
"\n"
"  float2 cp = closestPoint(x0, y0, x1, y1, x, y);\n"
"  float dist = hypot(cp.x - x, cp.y - y);\n"
"\n"
"  if (dist > minerror * 4) {\n"
"    numberout[p0] = 0;\n"
"    return;\n"
"  }\n"
"}\n"
"\n"
"__kernel void refine_pass0(global LSX_t *lsxListOut, global LS_t *lsListIn) {\n"
"  const int g = get_global_id(0)+1;\n"
"\n"
"  //if (g == 1) printf(\"sizeof LSX_t = %d\\n\", sizeof(LSX_t));\n"
"  \n"
"  int lsListSize = *(global int *)lsListIn;\n"
"  if (g > lsListSize) return;\n"
"\n"
"  if (lsListIn[g].polyid == 0) return;\n"
"\n"
"  lsxListOut[g].dirSE       = convert_short2(lsListIn[g].endCoords - lsListIn[g].startCoords);\n"
"  lsxListOut[g].vDirSE.x    = -lsxListOut[g].dirSE.y;\n"
"  lsxListOut[g].vDirSE.y    =  lsxListOut[g].dirSE.x;\n"
"  lsxListOut[g].mx00        = 0;\n"
"  lsxListOut[g].mx01        = 0;\n"
"  lsxListOut[g].mx11        = 0;\n"
"  lsxListOut[g].my0         = 0;\n"
"  lsxListOut[g].my1         = 0;\n"
"  lsxListOut[g].distSquSE   = lsxListOut[g].dirSE.x * lsxListOut[g].dirSE.x + lsxListOut[g].dirSE.y * lsxListOut[g].dirSE.y;\n"
"  lsxListOut[g].padding     = 0;\n"
"}\n"
"\n"
"int doti2(int2 x, int2 y) { return x.x * y.x + x.y * y.y; }\n"
"\n"
"#ifndef ENABLE_ATOMICS64\n"
"void xatom_add(volatile __global long *p, long val) {\n"
"  uint32_t l = val & (long)0xffffffff;\n"
"  int32_t h = val >> 32;\n"
"\n"
"  uint32_t o = atomic_add((volatile __global unsigned int *)p, l);\n"
"  if (o + l < o) h++;\n"
"  atomic_add(1 + (volatile __global int *)p, h);\n"
"}\n"
"#endif\n"
"\n"
"__kernel void refine_pass1(global LSX_t *lsxListIO, global LS_t *lsListIn, global int *lsIdIn, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  if (x >= iw || y >= ih) return;\n"
"  const int p0 = y * iw + x;\n"
"\n"
"  int lsListSize = *(global int *)lsListIn;\n"
"\n"
"  int g = lsIdIn[p0];\n"
"  if (g == 0) return;\n"
"\n"
"  if (g < 0 || lsListSize < g) {\n"
"#ifndef NDEBUG\n"
"    printf((constant char *)\"Too many linesegemnts at refine_pass1\\n\");\n"
"#endif\n"
"    return;\n"
"  }\n"
"\n"
"  int2 v = (int2)(x, y) - convert_int2_rte(lsListIn[g].startCoords);\n"
"  int ay  = doti2(v, convert_int2(lsxListIO[g].vDirSE));\n"
"  int ax0 = doti2(v, convert_int2(lsxListIO[g].dirSE));\n"
"  int ax1 = lsxListIO[g].distSquSE;\n"
"\n"
"#ifdef ENABLE_ATOMICS64\n"
"  atom_add(&(lsxListIO[g].mx00), convert_long_rte((float)ax0 * ax0));\n"
"  atom_add(&(lsxListIO[g].mx01), convert_long_rte((float)ax0 * ax1));\n"
"  atom_add(&(lsxListIO[g].mx11), convert_long_rte((float)ax1 * ax1));\n"
"  atom_add(&(lsxListIO[g].my0 ), convert_long_rte((float)ax0 * ay ));\n"
"  atom_add(&(lsxListIO[g].my1 ), convert_long_rte((float)ax1 * ay ));\n"
"#else\n"
"  xatom_add(&(lsxListIO[g].mx00), convert_long_rte((float)ax0 * ax0));\n"
"  xatom_add(&(lsxListIO[g].mx01), convert_long_rte((float)ax0 * ax1));\n"
"  xatom_add(&(lsxListIO[g].mx11), convert_long_rte((float)ax1 * ax1));\n"
"  xatom_add(&(lsxListIO[g].my0 ), convert_long_rte((float)ax0 * ay ));\n"
"  xatom_add(&(lsxListIO[g].my1 ), convert_long_rte((float)ax1 * ay ));\n"
"#endif\n"
"}\n"
"\n"
"__kernel void refine_pass2(global LSX_t *lsxListIn, global LS_t *lsListIO) {\n"
"  const int g = get_global_id(0)+1;\n"
"  \n"
"  int lsListSize = *(global int *)lsListIO;\n"
"  if (g > lsListSize) return;\n"
"\n"
"  if (lsListIO[g].polyid == 0) return;\n"
"  \n"
"  float rdet = (float)lsxListIn[g].mx00 * lsxListIn[g].mx11 - (float)lsxListIn[g].mx01 * lsxListIn[g].mx01;\n"
"\n"
"  if (rdet == 0) return;\n"
"\n"
"  rdet = 1.0 / rdet;\n"
"  float as0 = ((float)lsxListIn[g].mx11 * lsxListIn[g].my0 - (float)lsxListIn[g].mx01 * lsxListIn[g].my1) * rdet;\n"
"  float as1 = ((float)lsxListIn[g].mx00 * lsxListIn[g].my1 - (float)lsxListIn[g].mx01 * lsxListIn[g].my0) * rdet;\n"
"\n"
"  lsListIO[g].startCoords += convert_float2(lsxListIn[g].vDirSE) * as1;\n"
"  lsListIO[g].endCoords   += convert_float2(lsxListIn[g].vDirSE) * (as0 + as1);  \n"
"}\n"
"\n"
"__kernel void refine_pass3(global LS_t *lsListIO) {\n"
"  const int g = get_global_id(0)+1;\n"
"  \n"
"  int lsListSize = *(global int *)lsListIO;\n"
"  if (g > lsListSize) return;\n"
"\n"
"  if (lsListIO[g].polyid == 0) return;\n"
"\n"
"  const int h = lsListIO[g].rightPtr;\n"
"  if (h == 0) return;\n"
"\n"
"  float v0 = lsListIO[g].startCoords.x, v1 = lsListIO[g].startCoords.y;\n"
"  float v2 = lsListIO[g].endCoords.x  , v3 = lsListIO[g].endCoords.y  ;\n"
"\n"
"  float u0 = lsListIO[h].startCoords.x, u1 = lsListIO[h].startCoords.y;\n"
"  float u2 = lsListIO[h].endCoords.x  , u3 = lsListIO[h].endCoords.y  ;\n"
"\n"
"  float d = (v2 - v0) * (u3 - u1) - (v3 - v1) * (u2 - u0);\n"
"\n"
"  if (fabs(d) < 1e-6) {\n"
"    lsListIO[g].endCoords = lsListIO[h].startCoords =\n"
"      (lsListIO[g].endCoords + lsListIO[h].startCoords) * 0.5f;\n"
"    return;\n"
"  }\n"
"  \n"
"  float n = (v1 - u1) * (u2 - u0) - (v0 - u0) * (u3 - u1);\n"
"  float q = n / d;\n"
"\n"
"  float2 w = (float2)(v0 + q * (v2 - v0), v1 + q * (v3 - v1));\n"
"\n"
"  if (distance(w, lsListIO[g].endCoords) > 10 && distance(w, lsListIO[h].startCoords) > 10) {\n"
"    lsListIO[g].endCoords = lsListIO[h].startCoords =\n"
"      (lsListIO[g].endCoords + lsListIO[h].startCoords) * 0.5f;\n"
"    return;\n"
"  }\n"
"\n"
"  lsListIO[g].endCoords = lsListIO[h].startCoords = w;\n"
"}\n"
"\n"
"__kernel void labelxPreprocess_int_int(global int *label, global int *pix, global int *flags, int maxpass, int bgc, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  const int p0 = y * iw + x;\n"
"\n"
"  if (y == 0 && x < maxpass+1) {\n"
"    flags[x] = x == 0 ? 1 : 0;\n"
"  }\n"
"\n"
"  if (x >= iw || y >= ih) return;\n"
"\n"
"  if (pix[p0] == bgc) { label[p0] = -1; return; }\n"
"  if (y > 0 && pix[p0] == pix[p0-iw]) { label[p0] = p0-iw; return; }\n"
"  if (x > 0 && pix[p0] == pix[p0- 1]) { label[p0] = p0- 1; return; }\n"
"  label[p0] = p0;\n"
"}\n"
"\n"
"__kernel void label8xMain_int_int(global int *label, global int *pix, global int *flags, int pass, int iw, int ih) {\n"
"  const int x = get_global_id(0), y = get_global_id(1);\n"
"  if (x >= iw || y >= ih) return;\n"
"  const int p0 = y * iw + x;\n"
"\n"
"  if (flags[pass-1] == 0) return;\n"
"\n"
"  int g = label[p0], og = g;\n"
"\n"
"  if (g == -1) return;\n"
"\n"
"  for(int yy=-1;yy<=1;yy++) {\n"
"    for(int xx=-1;xx<=1;xx++) {\n"
"      if (0 <=  x + xx &&  x + xx < iw && 0 <=  y + yy &&  y + yy < ih) {\n"
"	const int p1 = (y + yy) * iw + x + xx, s = label[p1];\n"
"	if (s != -1 && s < g && pix[p0] == pix[p1]) g = s;\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"  for(int j=0;j<6;j++) g = label[g];\n"
"\n"
"  if (g != og) {\n"
"    atomic_min(&label[og], g);\n"
"    atomic_min(&label[p0], g);\n"
"    flags[pass] = 1;\n"
"  }\n"
"}\n"
"\n"
"__kernel void clear(global int *out, int size) {\n"
"  const int x = get_global_id(0);\n"
"  if (x >= size) return;\n"
"\n"
"  out[x] = 0;\n"
"}\n"
"\n"
"__kernel void copy(global int *out, global int *in, int size) {\n"
"  const int x = get_global_id(0);\n"
"  if (x >= size) return;\n"
"\n"
"  out[x] = in[x];\n"
"}\n"
"\n"
"ulong xrandom(ulong s) {\n"
"  int n;\n"
"  ulong t = s;\n"
"  n = (s >> 24) & 63; t = ((t << n) | (t >> (64 - n))); t ^= 0xf3dd0fb7820fde37UL;\n"
"  n = (s >>  6) & 63; t = ((t << n) | (t >> (64 - n))); t ^= 0xe6c6ac2c59e52811UL;\n"
"  n = (s >> 18) & 63; t = ((t << n) | (t >> (64 - n))); t ^= 0x2fc7871fff7c5b45UL;\n"
"  n = (s >> 48) & 63; t = ((t << n) | (t >> (64 - n))); t ^= 0x47c7e1f70aa4f7c5UL;\n"
"  n = (s >>  0) & 63; t = ((t << n) | (t >> (64 - n))); t ^= 0x094f02b7fb9ba895UL;\n"
"  n = (s >> 12) & 63; t = ((t << n) | (t >> (64 - n))); t ^= 0x89afda817e744570UL;\n"
"  n = (s >> 36) & 63; t = ((t << n) | (t >> (64 - n))); t ^= 0xc7277d052c7bf14bUL;\n"
"  return t;\n"
"}\n"
"\n"
"__kernel void rand(global int *out, ulong seed, int size) {\n"
"  const int x = get_global_id(0);\n"
"  if (x >= size) return;\n"
"\n"
"  out[x] = (int)xrandom((x    ^ 0xb21c2cb635b48285UL) * 0x9b923b9cec745401UL +\n"
"			(seed ^ 0x7bb93d75a79d2f15UL) * 0x22cab58ada573a29UL);\n"
"}\n"
;
